Our algorithms assume a message passing model of distributed computing. Therefore, we make the following two assumptions. First, communication rounds proceed synchronously. Second, each node can communicate with each of its neighbors once during any communication round. Structurally, our algorithms map each vertex of the graph to a compute node of the distributed computer. 

We also use the term `round' in two different senses. A computation round in our algorithm is composed of several communication rounds. Referring to the automata in Figure~\ref{fig:automata}, the automata defines the possible states of a node during a single computation round. We describe these steps in more detail in Section~\ref{sec:framework}.

A key point is that nodes are assumed to move synchronously through the stages of the automata regardless of whether they send or receive messages in any given phase. We place certain restrictions on what computations a node will make and on what messages a node will consider addressed to itself in any given round, but our model does not rely on such messages to keep the nodes moving forward.

The model itself does not limit or specify message complexity, and the algorithms in the paper have vastly different computational needs. The message complexity for each algorithm will be addressed in the appropriate sections.

The purpose of the our framework is to generate a matching\footnote{A matching for a graph $G(V,E)$ is a subset $E' \subset E \suchthat \forall\, e(u,v), e'(u,w), e''(v,x) \in E, e \in E' \implies e' \notin E', e'' \notin E'$. Less formally, no two contiguous edges are in the matching.} on the graph in each computation round. If a problem can be solved by performing some calculation on each edge of the graph in random order, then we can perform the calculation simultaneously on every edge in a matching.  
